# 기술 스택 의사결정 문서

> 프로젝트의 주요 기술 선택과 그 근거를 기록합니다.

---

## 📦 1. 프로젝트 구조: 단일 프로젝트

### 결정
**단일 프로젝트 구조 채택** (모노레포에서 전환)

### 이유
- **프로젝트 목적**: UI 패턴 학습/연습이 목적이므로 복잡한 구조 불필요
- **개발 편의성**: 한 폴더에서 모든 코드 관리, import 경로 단순
- **설정 최소화**: package.json 하나, workspace 설정 불필요
- **집중**: 빌드/배포 고민 없이 패턴 구현에만 집중

### 이전 구조 (모노레포)
```
packages/
  ├── core/           # vanilla 로직 (re-export)
  ├── react/          # React 래퍼 (re-export)
  ├── patterns/
  │   ├── modal/
  │   └── badge/
  └── examples/
pnpm-workspace.yaml
```

### 현재 구조 (단일 프로젝트)
```
src/
  ├── patterns/
  │   ├── _shared/    # 공통 유틸 (colors 등)
  │   ├── modal/
  │   │   ├── core/   # vanilla 로직
  │   │   └── react/  # React 컴포넌트
  │   ├── badge/
  │   │   └── react/
  │   └── switch/
  │       └── react/
  ├── App.tsx         # 데모/테스트용
  └── main.tsx
package.json          # 단일 package.json
```

### 왜 모노레포에서 전환했나?
| 모노레포 | 단일 프로젝트 |
|---------|-------------|
| 패턴별 독립 배포 가능 | 배포 계획 없음 (학습 목적) |
| workspace 설정 복잡 | 설정 단순 |
| 각 패키지별 node_modules | 루트에 하나만 |
| core/react 레이어 관리 | 필요 없음 |

### 트레이드오프
- ✅ 장점: 단순함, 빠른 설정, 학습에 집중
- ❌ 단점: 패키지 분리 배포 불가 (필요 없음)
- 💡 결론: 목적(학습)에 맞는 가장 단순한 구조 선택

---

## 🔧 2. 빌드 도구: Vite

### 결정
**Vite 사용** (개발 서버 + 빌드 도구)

### 이유
- **빠른 개발 서버**: ESM 기반 번들링 없는 개발 환경
- **간단한 설정**: 최소한의 설정으로 TypeScript, JSX 지원
- **HMR 지원**: 코드 수정 시 즉시 반영
- **경험**: 이미 사용해본 경험이 있어 생산성 높음

### 다른 선택지
1. **webpack**: 설정 복잡, 느림
2. **Rollup**: 개발 서버 없음
3. **tsup**: 라이브러리 빌드 특화, 개발 서버 없음

### 트레이드오프
- ✅ 장점: 빠른 개발 경험, 간단한 설정
- ❌ 단점: 세밀한 번들 최적화 어려움 (필요 없음)

---

## 📦 3. 패키지 매니저: pnpm

### 결정
**pnpm 사용**

### 이유
- **디스크 효율성**: 중앙 저장소에 패키지를 한 번만 저장하고 심볼릭 링크 사용
- **빠른 설치**: 병렬 설치 + 캐싱으로 npm/yarn보다 빠름
- **엄격한 의존성**: 유령 의존성(phantom dependencies) 방지

### 개념 설명
```bash
# pnpm의 node_modules 구조
node_modules/
  ├── react -> .pnpm/react@18.3.1/node_modules/react  (symlink)
  └── .pnpm/
      └── react@18.3.1/
          └── node_modules/
              └── react/  (실제 파일)
```

- 같은 버전의 패키지는 시스템 전체에서 단 한 번만 저장
- 다른 프로젝트에서 같은 패키지 설치 시 → 링크만 생성 (초고속)

### 트레이드오프
- ✅ 장점: 빠름, 디스크 효율, 안전한 의존성
- ❌ 단점: 일부 도구와 호환성 문제 (극히 드뭄)

---

## 🏗️ 4. 아키텍처: 패턴 중심 구조

### 결정
**각 패턴이 독립적으로 완결되는 구조**

```
src/patterns/
  modal/
    core/       # vanilla 로직 (상태, 키보드, 포커스 등)
    react/      # React 컴포넌트
  badge/
    react/      # 단순 컴포넌트는 core 없이도 OK
  switch/
    react/
```

### 이유
1. **한 폴더에서 완결**: modal 작업 시 modal 폴더만 보면 됨
2. **필요에 따른 구조**: 복잡한 패턴은 core/react 분리, 단순한 건 react만
3. **학습 효율**: 패턴별로 집중 학습 가능

### 언제 core를 분리하나?
| core 필요 | core 불필요 |
|----------|------------|
| Modal (포커스 트랩, 키보드) | Badge (순수 표시) |
| Dropdown (상태 관리) | Button (이벤트만) |
| Tabs (키보드 내비게이션) | Spinner (CSS만) |

### 트레이드오프
- ✅ 장점: 패턴에 집중, 유연한 구조
- ❌ 단점: 일관성 없음 (패턴마다 구조 다름)
- 💡 결론: 학습 목적에는 유연함이 더 중요

---

## 🎨 5. 스타일링: Emotion

### 결정
**Emotion 사용** (`@emotion/react`, `@emotion/styled`)

### 이유
1. **MUI 경험 활용**: sx prop 문법이 익숙함
2. **빠른 개발**: 러닝커브 없이 바로 생산성 높게 개발
3. **동적 스타일링**: props 기반 스타일 변경 용이
4. **같은 파일에서 관리**: 컴포넌트와 스타일을 함께 볼 수 있음

### 다른 선택지
1. **CSS Modules**: 제로 런타임이지만 동적 스타일링 불편
2. **Tailwind**: 빠르지만 라이브러리에 종속성 추가
3. **Vanilla Extract**: 타입 안전하지만 러닝커브 있음

### 트레이드오프
- ✅ 장점: 익숙한 문법, 빠른 개발, 동적 스타일링
- ❌ 단점: 런타임 오버헤드 (~10KB)
- 💡 결론: 학습 목적이므로 개발 속도 우선

---

## 📊 의사결정 요약표

| 항목 | 선택 | 핵심 이유 |
|-----|------|----------|
| **프로젝트 구조** | 단일 프로젝트 | 학습 목적에 단순함이 최선 |
| **빌드 도구** | Vite | 빠른 개발, 간단한 설정 |
| **패키지 매니저** | pnpm | 빠름, 디스크 효율 |
| **아키텍처** | 패턴 중심 | 한 폴더에서 완결 |
| **스타일링** | Emotion | 익숙함, 빠른 개발 |

---

## 🎯 결론

이 기술 스택은 **UI 패턴 학습/연습**이라는 목적에 맞게 선택했습니다:

1. **단순함 우선**: 복잡한 모노레포 대신 단일 프로젝트
2. **패턴에 집중**: 빌드/배포 고민 없이 구현에만 집중
3. **빠른 피드백**: Vite + HMR로 즉시 결과 확인
4. **유연한 구조**: 패턴 복잡도에 따라 core/react 분리 여부 결정

---

**작성일**: 2025-11-07
**최종 업데이트**: 2025-01-11 (모노레포 → 단일 프로젝트 전환)
